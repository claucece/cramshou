## #############################################################
## Tentative annoucements of the Cramer Shoup Crypto System
## in NEWSGROUPS (sci.crypt)
## 
## Synopsis:
##  Cramer Shoup Crypto System
## #############################################################
## @TABLE OF CONTENTS:		       [TOCD: 12:10 21 Nov 2004]
##
##  [1] 2004-09? (done, but reply was lost)
##  [2] 2004-11-21
## ##########################################################
## @FILE:    announce.txt
## @PLACE:   Linux Homestation
## @FORMAT:  txt
## @AUTHOR:  M. Oliver M'o'ller     <omoeller@verify-it.de>
## @BEGUN:   Sun Jul 18 13:32:28 2004
## @VERSION: Sun Jul 18 14:22:07 2004
## #############################################################
## @SPELL:   british 			Sun Nov 21 12:10:09 2004

Announcements in Usegroups:

## ###################################################################
## [1] 2004-09? (done, but reply was lost)
## ###################################################################

Subject: Java Implementation: Cramer-Shoup 98 Crypto System

Hello Crypto-Community.

I'd like to announce the availability of an Java Implementation of the
Cramer-Shoup public key crypto system [CS98]. This includes:

a. the implementation of en/de-cryption algorithm, where arbitrary length
   bit lists serve as input ; encryption pads the last block with random
   numbers and uses perfect hashing
b. a Java front-end that allows inclusion of the algorithm in a HTML page
   via an Applet. A base64-style ASCII armour is used to represent the
   crypto-text.  The same front-end can be used to encrypt/decrypt files
   from command line
c. a key generation algorithm (again, in Java) that generates a compile-able
   CrytoModule.java file, which contains the public and the secret key.

If you want to try it from command line, you need a working Java environment
(1.1.4 or higher) and follow the following steps:

1. Download the sources of both key-generator and front-end at:
   http://www.verify-it.de/applets/KeyGeneratorCS.java
   http://www.verify-it.de/applets/Crypter.java

2. Compile the Key Generator:
   javac KeyGeneratorCS.java

3. Generate a key and direct it to a .java file, e.g., by doing :
   java KeyGeneratorCS -f CryptoModule.java -o "YOUR NAME <YOUR@EMAIL>" -n KEYNAME 

4. Compile the generated key, together with the front-end (Crypter):
   javac -classpath . CryptoModule.java Crypter.java

5. Now you are ready to en-decrypt from command line:
   java Crypter e MESSAGE.txt CRYPTO.txt
   java Crypter d CRYPTO.txt  DECRYPTED.txt

NOTES:
I) Since there is some random padding, the de-crypted message has some 
   'random garbage' at the end.
   In order to avoid this, the string constant "\n*\n" is always appended 
   to the message text before encryption.
   Decryption truncates the smallest tail starting with this string, which
   (except for some very unlikely padding) yields exactly the clear text
   message.
   You can suppress truncation by using 'u' (un-truncated) instead of 'd':
     java Crypter u CRYPTO.txt  DECRYPTED.txt

II) File encoding is by default assumed to be 8bit/character.
    You can set bits/character explicitly by command line option -7,-8,-16.

III) If you plan to make public key encryption directed to you available on
     the web (as done on my web pages), you have to make a copy of the the
     CryptoModule.java (to a different directory) and REMOVE the secret key
     part, eg., by replacing it with nonsense data:

      byte[] x1 = { 0 } ;
      byte[] x2 = { 0 } ;
      byte[] y1 = { 0 } ;
      byte[] y2 = { 0 } ;
      byte[] z = { 0 } ;

IV) You can play with en/decryption in your browser for a toy key-pair (here,
    the private key is included in the web-accessible .class file:

    http://www.verify-it.de/sub/toycrypt/toycrypter.html

V) This release (Crypter, Version 2.0.12) fixes 
   - previous problems with 7/8-bit encoding (Java FileReader issues) and is
     compatible with keys/crypto texts generated with Version 1.6.x.
   - a potential inversion problem with number 0 (which has no inverse)

More information can be found at 

  http://www.verify-it.de/sub/cramer_shoup.html

The algorithm was tried and tested on several platforms (SuSE-Linux, Cygwin)
and browsers (Netscape, Mozilla, konqueror, IE), but there is of course no
warranty that it will work in any setting.

Please send problem reports to <omoeller@verify-it.de>.
Comments and suggestions are also welcome.

References:
[CS98] Ronald Cramer and Victor Shoup: A practical public key crypto system provably secure against adaptive chosen ciphertext attack. in proceedings of Crypto 1998, LNCS 1462, p.13ff

- oli						       http://www.verify-it.de
*com-pu-ter*: device to enhance our capability to err. <omoeller@verify-it.de>


## ###################################################################
## [2] 2004-11-21: posted in sci.crypt via server 'news'
## ###################################################################

From: Oliver Moeller <omoeller@verify-it.de>
Subject: Padding Question (Cramer-Shoup 98 Crypto System)

Hello Crypto-Community.

I have a Java implementation of Cramer-Shoup 98 Crypto System (see links
below). Version 2.1 now guarantees to de-crypt to the original message by
introducing a safe way to pad the clear text message up to the required block
size.

They padding I chose is rather straightforward:

(I)
Always append a bit pattern of fixed (16 bits) length:
    1000 1000 1000 1000 
The encryption does pad the message with a pattern (01|10)*[0]?, where
01 / 10 are picked uniformly random.

For n > 16 (realistic values are around 2000), this reduces the number of
messages from 2^n to (at least) 2^((n-16)/2).

Lets assume the somewhat "worst case": 
The clear text message contains only 1 bit, the 'random' tail is of length
n-1. Then only the fraction 0.5*(n-17)/n of clear text messages have to be
considered in order to distinguish message '0' and message '1'.

This fraction is close to 0.5, so for practical matters this is not too bad.
In case of Cramer-Shoup, where a library of pre-computed cipher-texts do not
help (much), my claim is that this does not compromise security.

However, I have the feeling that there is a better way to do this.
My last lecture on Cryptography was in 2000, so I had a look at the omniscient
garbage dump for 'cryptographic padding' and found PKCS5:

(II)
## -- quote from http://www.chilkatsoft.com/faq/PKCS5_Padding.html 
 PKCS#5 padding works as follows: the bytes remaining to fill a block are
 assigned a number, which is the number of bytes that were added to fill the
 block. For instance, if we have an 16-byte block, and only 11 bytes are
 filled, then we have 5 bytes to pad. Those 5 bytes are all assigned the value
 "5", for the 5 bytes of padding.

For the 1-bit example (assuming the attacker guesses that there is only 1
bit), it seems to be horribly bad (you can readily construct a library of
cipher-texts).


My Questions:
(1) Is (I) an acceptable way to pad? 
(2) Is (II) PKCS5 better than padding with 10* ? 
(3) Is there a suggested or even 'optimal' way to pad?

Thanks.

--

About the Java Implementation of Cramer-Shoup 98:

Though I do not assume this being a research topic, I'd like to point out some
(IMHO) interesting features of this implementation.

1. A Java front-end allows inclusion of the algorithm (and your public key) in
   a HTML page via an Applet. 
2. The same front-end can be used to encrypt/decrypt files from command line
3. The implementation is fairly small and can be realistically checked for
   correctness by manual code-inspection.

Resources:
A test suite for the implementation (including the key-generator) is
available. After un-zipping, call 'make' to generate a number of keys and test
proper en/de-cryption of random messages. This will abort if clear text
message and de-crypted cipher-text differ.
  http://www.verify-it.de/sub/testCrypter.zip

More information can be found at 
  http://www.verify-it.de/sub/cramer_shoup.html

References:
[CS98] Ronald Cramer and Victor Shoup: 
       A practical public key crypto system provably secure against adaptive
       chosen ciphertext attack. 
       in proceedings of Crypto 1998, LNCS 1462, p.13ff

- oli						       http://www.verify-it.de
*com-pu-ter*: device to enhance our capability to err. <omoeller@verify-it.de>



## ###############################################
## REPLIES
## ###############################################

From: Kristian Gjøsteen <kristiag+news@math.ntnu.no>
Subject: Re: Padding Question (Cramer-Shoup 98 Crypto System)
Newsgroups: sci.crypt
Date: Mon, 22 Nov 2004 09:36:42 +0000 (UTC)
Organization: Norwegian University of Science and Technology

Oliver Moeller  <omoeller@verify-it.de> wrote:
>I have a Java implementation of Cramer-Shoup 98 Crypto System (see links
>below). Version 2.1 now guarantees to de-crypt to the original message by
>introducing a safe way to pad the clear text message up to the required block
>size.
>
>They padding I chose is rather straightforward:
>
>(I)
>Always append a bit pattern of fixed (16 bits) length:
>    1000 1000 1000 1000 
>The encryption does pad the message with a pattern (01|10)*[0]?, where
>01 / 10 are picked uniformly random.
>
>For n > 16 (realistic values are around 2000), this reduces the number of
>messages from 2^n to (at least) 2^((n-16)/2).

Why so complicated?

Your message is a bit string of length l. What you need to do (if you
are using F_p* where p is a safe prime) is to embed that bit string as
a quadratic residue.

Assume p is k+1 bits long, and that l < k-9. Append a single 1 followed
by k-8-l 0 bits to the message. The result is exactly k-7 bits long.

Now append 0000000, and check if the resulting binary string has Legendre
symbol 1 when interpreted as an element in F_p*. If it doesn't, try
0000001, 0000010, 0000011, etc.

To extract the embedded message, discard the final 7 bits, then any
trailing zeros, then one one.

This embedding procedure will fail with a probability of roughly 2^128.
Many systems designers can accept that.

The cost is 10 bits plus an expected 2 Legendre symbol evaluations, which
corresponds roughly to two multiplications.

If you pardon my horrible Java code, this is the simplest possible
code I can come up with.

BigInteger embed_message_as_qr(BigInteger p, BigInteger m)
{
	int i;

	m = m.shiftLeft(1).setBit(0);
	m = m.shiftLeft(p.bitLength()-9-m.bitLength());

	for (i = 0; i < 128; ++i)
	{
		if (Legendre(m,p) == 1)
			return m;
		m.add(BigInteger.ONE);
	}
	return BigInteger.ONE.negate();
}

Implementing Legendre(x,p) is left as an exercise for the reader.

-- 
Kristian Gjøsteen

## -------------------------------------------------------------

From: "David A. Scott" <daVvid_a_scott@email.com>
Subject: Re: Padding Question (Cramer-Shoup 98 Crypto System)
Newsgroups: sci.crypt
Date: 23 Nov 2004 15:42:05 GMT
Organization: Your Company

Oliver Moeller <omoeller@verify-it.de> wrote in 
news:87oehrgcl7.fsf@gaia.verify-it.de:

> 
> My Questions:
> (1) Is (I) an acceptable way to pad? 
> (2) Is (II) PKCS5 better than padding with 10* ? 
> (3) Is there a suggested or even 'optimal' way to pad?
> 
> Thanks.
> 
> 

   Yes there are much better ways to pad. You should at least
always use some form of bijective padding weither or not your
adding random data.


David A. Scott
-- 
My Crypto code
http://bijective.dogma.net/crypto/scott19u.zip
http://www.jim.com/jamesd/Kong/scott19u.zip old version
My Compression code http://bijective.dogma.net/
**TO EMAIL ME drop the roman "five" **
Disclaimer:I am in no way responsible for any of the statements
 made in the above text. For all I know I might be drugged.
As a famous person once said "any cryptograhic
system is only as strong as its weakest link"

## -------------------------------------------------------------

From: karl_m@acm.org
Subject: Re: Padding Question (Cramer-Shoup 98 Crypto System)
Newsgroups: sci.crypt
Date: 23 Nov 2004 11:00:46 -0800
Organization: http://groups.google.com


David A. Scott wrote:
> Oliver Moeller <omoeller@verify-it.de> wrote in
> news:87oehrgcl7.fsf@gaia.verify-it.de:
>
> >
> > My Questions:
> > (1) Is (I) an acceptable way to pad?
> > (2) Is (II) PKCS5 better than padding with 10* ?
> > (3) Is there a suggested or even 'optimal' way to pad?
> >
> > Thanks.
> >
> >
>
>    Yes there are much better ways to pad. You should at least
> always use some form of bijective padding weither or not your
> adding random data.

1. Reversible.
2. Unique.
3. Random.

Do you have additional attributes for bijective?  karl m


## -------------------------------------------------------------

From: Mark Wooding <mdw@nsict.org>
Subject: Re: Padding Question (Cramer-Shoup 98 Crypto System)
Newsgroups: sci.crypt
Date: Wed, 24 Nov 2004 13:08:35 +0000 (UTC)
Organization: National Society for the Inversion of Cuddly Tigers

Oliver Moeller <omoeller@verify-it.de> wrote:

> I have a Java implementation of Cramer-Shoup 98 Crypto System (see
> links below). Version 2.1 now guarantees to de-crypt to the original
> message by introducing a safe way to pad the clear text message up to
> the required block size.

Cramer-Shoup is IND-CCA2 out of the box, so your padding scheme doesn't
have to have any particularly interesting security properties.  CS
already takes care of randomizing the encryption, so padding can be
deterministic.  The /only/ job padding needs to do is injectively
transform your message into a member of the appropriate group.  This,
alas, is nontrivial.

CS wants to work in a group of prime order.  Your suggestions just
encode the message as a large integer and hope for the best, without
regard to whether the result is in the right subgroup of F_p^*.

The CS paper suggests using safe primes (i.e., p = 2 q + 1 with q
prime); then once you've encoded your message as an integer 1 <= m < q,
you can use m^2 as your message representative.  Recovery is a matter of
finding the square root in the right range, noting that x^2 = (p - x)^2
(mod p) and decoding the result.

If you're using more general primes then you have a more difficult
problem.  If p = q h + 1 for prime q, then you could proceed as above,
using m^h as your message representative.  However, extraction of h-th
roots mod p is a nontrivial job, particularly if you want the specific
one which lies between 1 and q, so this rapidly looks like a bad idea.
I found http://www.ma.utexas.edu/users/voloch/Preprints/roots.pdf which
shows how to find roots in finite fields, but doesn't seem to be of much
use if you really want /this particular one/.  I think this approach is
doomed to failure.

Encoding a message as an integer in 1, ..., q - 1 is straightforward.
Suppose that 2^{8 b - 1} <= q < 2^{8 b}, i.e., q needs b bytes to write
it down.  Your message M must be b - 2 bytes long or less.  Let M' = 00
|| ZZ || 01 || M', where ZZ is a string of zero bytes long enough to
make M' be b bytes long.  Transform M' into an integer using the big-
endian convention.  Decoding is obvious.

If you're doing CS on an elliptic curve then life is actually a little
easier.  Suppose we need b bytes to represent a field element.  Choose
some n, about 4 is enough; you'll be able to represent messages M which
are b - n - 2 bytes long with failure probability 2^{-8 n}.  Simply
encode M as M' = 00 || I || ZZ || 01 || M, where I is an n-byte counter
starting at 0, and ZZ is a string of zero bytes long enough to make M'
be b bytes long.  Now, transform M' into a field element x (using OS2FEP
or whatever) and see if there's a y such that (x, y) is (a) on your
curve and (b) in the right subgroup.  If not, then step I on one and try
again.  Each try will succeed with probability about 1/2^{1 + h}, where
h is the curve's cofactor.  Decoding is again obvious.

Actually, the hybrid approach seems superior in almost every respect.
Choose a random group element, and hash it to obtain a session key for a
symmetric IND-CCA2 encryption scheme.  Encrypt your group element with
CS and append the ciphertext of your message encrypted under the session
key.  (In practice, DLIES is almost certainly a better bet -- it's
simpler and faster.  But I'm guessing this is about CS being cool rather
than practical, and there's nothing wrong with that.)

-- [mdw]


## ----------------------------------------------------

From: Michael Amling <nospam@nospam.com>
Subject: Re: Padding Question (Cramer-Shoup 98 Crypto System)
Newsgroups: sci.crypt
Date: Wed, 24 Nov 2004 14:43:32 GMT
Organization: SBC http://yahoo.sbc.com

Mark Wooding wrote:
> If you're using more general primes then you have a more difficult
> problem.  If p = q h + 1 for prime q, then you could proceed as above,
> using m^h as your message representative.  However, extraction of h-th
> roots mod p is a nontrivial job, particularly if you want the specific
> one which lies between 1 and q, so this rapidly looks like a bad idea.

   I would think the method used to find RSA private keys would work here. Let
d=h**-1 mod p-1. Then m=c**d mod p is one value of c**(1/h). If that's not the
one you want, multiply by the h-1 roots of 1 mod p to find the others.
   Note: I don't know how to find the h-1 non-trivial roots of 1 mod p, but
you'd only have to do it once, not once per message. If that's what you're
saying is non-trivial, then I agree.


> I found http://www.ma.utexas.edu/users/voloch/Preprints/roots.pdf which
> shows how to find roots in finite fields, but doesn't seem to be of much
> use if you really want /this particular one/.  I think this approach is
> doomed to failure.

--Mike Amling

## ----------------------------------------------------

From: Kristian Gjøsteen <kristiag+news@math.ntnu.no>
Subject: Re: Padding Question (Cramer-Shoup 98 Crypto System)
Newsgroups: sci.crypt
Date: Wed, 24 Nov 2004 15:37:11 +0000 (UTC)
Organization: Norwegian University of Science and Technology

Michael Amling  <nospam@nospam.com> wrote:
>Mark Wooding wrote:
>> 
>> If you're using more general primes then you have a more difficult
>> problem.  If p = q h + 1 for prime q, then you could proceed as above,
>> using m^h as your message representative.  However, extraction of h-th
>> roots mod p is a nontrivial job, particularly if you want the specific
>> one which lies between 1 and q, so this rapidly looks like a bad idea.
>
>   I would think the method used to find RSA private keys would work 
>here. Let d=h**-1 mod p-1. Then m=c**d mod p is one value of c**(1/h). 
>If that's not the one you want, multiply by the h-1 roots of 1 mod p to 
>find the others.
>   Note: I don't know how to find the h-1 non-trivial roots of 1 mod p, 
>but you'd only have to do it once, not once per message. If that's what 
>you're saying is non-trivial, then I agree.

Finding h-1 non-trivial roots of 1 mod p is the same as finding an element
of order h. This is easy if you know h, q and any small factors of h.
(Choose a random element, raise it to the qth power, check that it has
order h.)

The problem is that h is typically large (say 2^860 when q is ~2^160).
But if h is small it could be done as you suggest.

But you don't really want a PKC, you want a KEM, and then you should
use the CS03-KEM or the newer variants based on Desmedt and Kurosawa.
They can use small subgroups without any problems.

-- 
Kristian Gjøsteen

## -------------------------------------------------------------

From: Michael Amling <nospam@nospam.com>
Subject: Re: Padding Question (Cramer-Shoup 98 Crypto System)
Newsgroups: sci.crypt
Date: Wed, 24 Nov 2004 19:55:08 GMT
Organization: SBC http://yahoo.sbc.com

Kristian Gjøsteen wrote:
> The problem is that h is typically large (say 2^860 when q is ~2^160).

   Oh, of course. I was thinking of the h ECC, where h is no more than 16.

> But if h is small it could be done as you suggest.

--Mike Amling


## -------------------------------------------------------------------------
