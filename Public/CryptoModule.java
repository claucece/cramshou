/************************************************************
 * @(#)CryptoModule.java
 * 
 * Generated by KeyGeneratorCS V 1.2 $Revision: 1.6 $ $Date: 2004/11/10 08:17:08 $
 * Created : Nov 1, 2015 11:48:13 AM
 *
 * Requires: java 1.1.5 (or higher)
 * 
 * 
 *           [as e.g. provided in Netscape 4.06]
 *
 * References:
 * 
 * [CS98] Ronald Cramer and Victor Shoup: A practical public key crypto
 *        system provably secure against adaptive chosen  ciphertext attack
 *        in proceedings of Crypto 1998, LNCS 1462, p.13ff  
 * 
 * No Copyright (!c)
 */


import java.math.BigInteger;
import java.util.Random;

  /**
   * CryptoModule implements the Cramer-Shoup 
   * public key Crypto Algorithm
   *
   * If you want to use it, you can find more information on:
   * <PRE>
   * see: http://www.verify-it.de/sub/cramer_shoup.html
   *      http://www.verify-it.de/sub/crypter.html
   *      http://www.verify-it.de/applet/KeyGeneratorCS.java
   * </PRE>
   * 
   */
public class CryptoModule {

    /************************************************************
     * Public and secret keys
     ************************************************************/
    
  public String keyNameString = "Method:   Cramer-Shoup98\nKey-Name: My Name-2064\nOwner:    My Name <my-mail>\n";
  
  private SecretKey sk;
  private PublicKey pk;
  
  private Random rnd;
  
  public CryptoModule(){
    
    /****************************************
     * Initialize:
     * Set the keys to personal adjustings
     ****************************************/
    
    /*
     * Method:   Cramer-Shoup98
     * Key-Name: My Name-2064
     * Owner:    My Name <my-mail>
     */
    
    byte[] p = { 0, -53, 60, -70, -76, 95, -59, -84, 114, -36, -39, 90, -126, -7, 122, -106, 55, -55, 120, -101, 36, -111, 11, 112, 98, 95, 11, 47, 34, -127, -22, 112, -26, -16, 117, 75, -114, -35, -17, 106, 114, -8, -59, 17, 39, -127, 51, -77, 83, -127, -101, -45, -79, -45, 98, 26, 125, 58, -70, 103, -44, -30, -115, 90, -114, -18, 102, 39, 61, -49, -74, 15, 83, -58, -46, -78, 61, 15, 18, -73, -37, 107, -86, 3, 95, -50, -75, 93, 61, -11, -122, 22, 121, 25, 20, -23, -72, -111, 16, -109, 54, -34, 120, -61, -75, -123, 53, -20, -8, 70, -110, 85, -96, 40, 13, -121, -69, -103, 122, -113, -49, -55, -6, -106, 98, 39, -50, -34, -81, 3, 47, 9, -111, 97, 120, -26, 56, -35, -103, 88, 98, 5, 122, -70, 20, 3, 117, 123, -84, 39, 83, 36, 44, -83, 69, -71, 46, 88, -17, -13, 54, 43, 121, -97, 15, -82, -49, -36, 44, -115, 122, -88, 64, -98, -37, 2, 81, -14, 105, 23, -112, 99, 5, -37, -85, 38, -124, -105, 61, -36, 34, 25, -35, -46, -32, 119, -36, -113, 51, 76, 98, -4, -125, -12, -30, 49, -64, 21, 86, 64, 115, -115, 11, 6, 87, 38, -108, 53, 40, -84, 21, 45, -76, 120, 15, 8, 106, 62, 33, -16, 62, -38, 91, 59, -112, -37, -90, 127, -10, -128, 97, 14, 79, -54, -124, -61, -43, 103, 96, -39, 29, -15, 16, 61, -29, 92, -125, 47, -37 };
    byte[] hg1 = { 61, -110, -93, 0, -74, 125, 106, -69, -21, -17, 92, 62, -23, -96, -82, 17, 47, 49, -125, -25, -115, 98, -97, -98, 106, -59, -75, 101, 92, -16, 109, 54, 111, 10, 48, 80, -42, 119, -31, -61, -100, 46, -108, 46, 57, 87, -120, -52, -13, -61, -110, 71, 71, -59, 58, 75, -15, 73, 97, -93, 114, -120, -117, 116, -14, -49, 22, 90, 35, -99, 86, -31, 91, -88, -66, -51, 57, 100, -50, 120, -18, -124, 31, -85, -15, 109, -96, -117, -19, 78, -3, -71, -42, 2, -58, -19, -11, 49, 104, -12, 110, 123, 17, 93, -66, -82, -48, 95, -71, 24, 32, -49, 35, -77, -102, 58, -60, -78, 108, 5, 19, -73, 94, 23, -46, 7, 23, 57, 106, 74, 28, -113, -6, 13, -25, 44, -68, 101, 60, 48, 32, 50, -27, 111, -107, -64, -56, 80, -82, 58, 46, 11, -66, 121, -8, -2, -120, 97, -126, 39, -119, 18, 80, 114, 2, 120, -90, 57, 50, 44, -52, 43, -25, 88, 47, -11, -50, 46, 107, 77, -44, -33, -45, 48, 108, 19, 36, 68, 106, -30, 0, -32, 77, -121, 96, 42, 49, -113, 114, 111, 94, -108, 49, -9, 28, -17, -36, 22, 91, 123, -103, -101, 10, 98, 4, -22, 62, -122, -41, 13, -64, -101, 113, 46, -11, -35, -107, 25, 40, 54, -46, -6, 103, -20, 74, 14, -32, 46, -41, 73, 77, 28, -101, 108, 93, -23, -55, -73, 124, -22, -22, -83, 37, 100, 11, -30, -123, -54 };
    byte[] hg2 = { 13, 110, 117, 73, -125, 115, -23, -30, 109, -68, 55, -93, 122, -22, -119, 12, 58, -68, -79, -9, -55, -114, 73, -56, -19, -10, 57, 25, 52, 73, 68, 10, -67, 83, 69, 123, 108, -26, -69, -113, 104, -70, -6, 78, 94, 97, 111, -124, -21, -28, -40, -27, 102, 27, 10, -34, -126, 70, 44, -22, 1, 72, -73, -45, 7, 54, -83, -105, -121, -96, -65, 28, 18, -83, -99, -128, 55, 109, -17, 75, 10, 11, 14, 21, 72, -74, 41, 18, 127, -31, -95, -81, -74, 86, -51, -74, -80, -23, 57, 6, 34, -40, 62, -100, 90, -95, 44, -78, 53, 41, -43, 19, -119, 89, 122, -27, 45, 83, 17, -90, -84, -117, -40, 103, -115, 35, -102, 88, 68, -13, 105, 127, 50, -81, -13, 20, -116, 56, 96, -39, -67, 20, -45, 67, 19, -56, 45, 19, -124, 105, -87, 5, 22, -36, 26, 86, 42, 12, 60, -79, 56, 56, 8, 9, -127, -47, -77, -7, 32, 93, -17, 118, -75, -52, 40, 100, -110, -19, 27, -58, -34, 116, -33, -66, -61, -56, 96, -27, 125, 107, 40, -105, 62, 37, 12, 103, -70, -108, -108, 117, -87, 24, -93, -60, -84, -30, -63, -21, -7, -43, 100, -96, -115, -21, 91, -90, 62, 46, 90, -76, -27, 26, -75, 42, 108, -42, -38, 125, 52, -25, 123, 17, 86, -77, 53, 84, 127, 120, 29, -124, 77, 82, 79, -103, 3, -108, 94, 116, -103, -85, -20, 30, 121, -81, -9, -98, -92, 10 };
    
    byte[] g1 = { 53, -95, -24, -79, -74, 44, 68, -61, 63, 90, 46, 37, -118, 126, -79, 123, 94, -61, 1, 5, -7, 77, -31, 5, -111, 35, 55, -49, 85, -63, 23, 28, 92, 81, -59, 117, -70, -47, 72, -74, 96, 28, -45, -36, -8, -39, 82, -58, 87, 12, 66, -112, -19, 122, -56, 107, -17, -48, 61, -31, -97, 77, 73, 92, -96, 115, -102, 30, 127, 36, 112, -58, -28, -62, -69, 114, -77, -105, 42, -53, -34, 68, 102, -94, -124, 34, 73, 57, -35, 63, -42, 71, 88, -5, 113, -33, 5, 32, 102, 45, -33, -31, -40, -114, -28, -73, 78, -32, -8, -25, 97, 3, 73, -52, -23, -26, -88, 78, 27, 87, 25, -97, 70, 113, 50, -77, -113, -61, -56, -61, -106, -32, 14, 23, 62, 10, 28, -54, 73, 91, -57, -98, -98, -91, 52, 90, -69, -83, -113, -111, -12, 96, 28, -48, 117, 4, 111, 7, 78, -45, 60, -89, -101, -84, 105, 40, -74, -110, 29, -106, -106, -69, -92, 18, 98, -25, 0, 66, 34, 107, 84, 41, 98, -18, 108, -1, -89, 111, 4, -127, -60, -94, 117, -45, -12, -34, 110, 71, -77, -39, 91, -37, 0, -76, 103, -22, -81, 109, -1, -57, -94, 23, 73, -93, -113, -32, 5, 58, -44, 56, -128, -64, 28, -106, 40, 25, 117, 13, -21, 45, -73, 45, -81, 105, 69, -67, -100, 39, 79, -86, 119, -26, -28, -92, -86, 42, 55, 124, 91, -69, -62, -107, -79, -38, 112, -20, 56, 59 };
    byte[] g2 = { 3, -109, 15, 66, -49, 44, 5, -10, 94, -112, -74, -45, -16, 101, 63, 47, 36, -77, -107, 111, -102, 43, 57, 121, 0, 9, -16, -4, 23, 6, -104, 81, 79, -105, -87, 52, 52, -81, -48, -94, 3, 81, 16, -112, -39, -46, 99, -102, 26, 4, 112, -128, -93, -28, -22, 83, -23, 81, 113, 104, 56, -16, -81, 37, -59, 106, 12, -44, 46, 38, 113, 19, -56, -116, -104, -57, -75, -67, -46, -21, -45, -2, 38, -37, 103, 35, 1, -77, -11, -69, -115, 72, -14, 103, -122, 92, -36, 16, 70, -48, 108, 5, 3, -28, -1, 91, -115, -91, -104, 112, -24, -53, -95, -62, -31, 119, 105, 19, 71, 45, -33, 79, -90, 15, 122, 80, 15, -38, 96, 104, -10, 91, 96, -101, 58, 93, 109, 20, 17, -27, -6, -105, 85, 117, 106, 43, 75, -39, 44, 35, 124, -33, 20, 55, 2, -19, -85, 49, -116, -17, -14, -63, -25, -12, -62, 37, -109, -78, -55, 3, -95, 125, 55, -85, 59, -67, 38, 80, -115, 92, -70, -32, 15, 12, 56, -98, -26, -35, -125, -88, 54, -26, -125, -58, -77, 69, 13, -10, -101, -70, 64, -6, -72, 16, 16, -27, 61, 94, 101, 81, -50, -124, 32, -26, -52, -66, -95, 103, -40, -13, -92, 103, -104, 125, -35, -83, -82, 119, 1, -90, 21, 97, -12, -92, 109, 35, 41, -52, -120, -102, -58, 119, 8, -109, -17, -43, 68, -67, -38, -83, 113, 125, -44, -57, -78, 111, 26, -57 };
    
    
    byte[] c = { 100, 15, 116, 71, 91, -86, 121, -1, -103, -53, 42, 63, 44, 101, -98, 44, -46, -11, -114, 98, 25, 53, -49, -50, 35, 18, 28, -30, -32, 80, -10, -115, -117, -41, 60, -99, -102, 41, -40, 24, 111, -93, 95, -80, -25, 21, 47, 79, -16, -55, 119, -28, -98, -122, 87, -71, -120, -114, 77, 85, -11, -87, 56, 45, 106, -49, 55, -28, -85, 48, -62, -111, 49, 77, 83, -83, 50, -55, -99, 44, -75, 109, 85, -31, -118, 97, 31, -21, -33, 125, -17, -90, 85, -121, 12, -96, 93, -109, 86, -66, 109, 73, 90, -22, 11, 9, -101, 13, -16, -61, 77, -47, -63, -40, 124, -92, -29, -120, 95, -24, 7, 98, 126, -99, -5, 11, -126, -92, -38, -111, 77, 57, -70, 5, 62, 79, -23, -92, 126, -91, -21, 122, 127, 8, -117, -116, -68, -67, 28, -100, 108, -74, -10, -6, -109, -75, 28, -16, 104, 91, 124, -112, -40, 120, -111, 34, 5, 120, 80, 55, -68, 48, -116, -25, -67, 85, 114, -100, 125, -123, -21, 35, -51, -8, 25, -59, 87, -98, -88, 63, 41, 40, 69, 105, 52, 112, 0, -89, 11, -99, 45, -67, 119, -98, -47, 57, -101, -43, 10, 97, -69, -111, 47, 94, 84, 127, -6, -33, -81, -42, 78, -32, -61, 104, -126, -107, 119, 117, -3, 88, -47, -53, 30, -44, -79, 100, 70, 34, 23, 29, -90, -55, -64, -89, 3, 38, 73, 1, -11, -31, -127, 49, 115, -19, -44, 23, 111, -76 };
    byte[] d = { 56, -8, 10, -94, 41, 76, -25, 19, 86, -91, -44, 126, -102, -65, -85, 25, 89, -44, -17, -93, 79, 126, 104, -46, -39, -20, -70, 114, -48, 18, -72, 59, -21, -4, 13, -69, 16, -73, -40, 105, 73, -118, 33, 71, -93, -68, -94, -9, -94, -114, -88, 50, -1, -38, 36, -45, 115, 6, 120, -120, -75, 10, 97, 42, 75, -120, 6, -92, 118, 24, 77, -122, -61, -99, 18, -79, -93, 37, 91, -113, 51, -75, 98, 27, 65, -36, 127, -33, -53, -26, -118, -40, 48, -77, 114, 105, 20, -33, -118, -123, -17, -105, 61, 119, -74, -106, 111, -114, 98, 43, 122, -10, -68, -48, 55, 57, 15, -59, 101, -112, -56, 106, 30, 118, 114, 127, -105, -89, 101, -76, 16, 28, 4, 86, -57, -77, -100, -82, 55, -8, -7, 113, 41, 15, 67, 91, 27, -89, 17, -124, -55, 67, -33, 93, -73, -28, 70, -39, 73, -72, -73, -48, 98, 11, 48, -118, -7, 110, -81, -72, 9, -63, -13, 41, 65, 6, 3, -35, -112, -41, 23, 43, -46, 66, 18, -125, 89, -26, 19, 113, -96, -75, -53, -97, -66, -94, 29, -71, 32, 83, 95, 45, 33, -23, 30, 73, -56, -84, 51, 65, -120, -26, -117, -41, -35, -94, 23, 66, 12, -72, -115, 114, 104, -65, 26, -123, -50, -105, -27, 21, 31, 20, 58, 4, -25, 121, -94, -50, 52, 84, -31, 11, -15, 80, -118, 93, 120, 56, 60, 93, -120, 64, 15, 97, -123, -16, -86, -118 };
    byte[] h = { 10, -52, -18, -41, -60, -1, 70, 22, -41, 79, -11, -87, -51, -4, -60, 117, 88, 112, -94, 14, -111, -109, -107, -63, -44, 101, -127, -10, 79, -95, -82, 103, 111, 127, -118, 56, 106, -66, 80, -27, -109, -78, -2, 127, -10, -52, 98, -60, 114, 53, -6, -1, 26, 23, 103, 51, -100, 107, 80, -112, -34, 64, 88, 38, 69, -61, -35, 1, 55, 80, 22, 34, -46, -83, -14, 99, -99, 112, -33, 94, -19, 58, 71, 10, -60, -31, -4, 57, 48, -113, -36, 18, 93, -76, -116, -123, -61, 24, 84, -95, 13, -84, 27, 39, 67, -80, 36, 44, -89, 11, -24, -69, -101, 73, -39, -27, -119, 119, 47, 109, -84, -18, -9, -72, -105, -15, -113, 126, -123, -31, 108, -127, 9, 49, 60, -18, 13, 74, 35, 102, 59, 31, 83, -83, -76, 121, 72, -16, -106, 118, 55, 96, -127, -5, 46, 49, -44, 86, 32, -22, 56, 71, -23, -86, 69, -62, -117, -82, -107, -100, -32, 59, 9, 117, -43, 120, 80, -122, 28, 95, -99, 100, 79, 124, -94, -104, 64, -41, 120, -11, 61, -45, 2, -28, 30, -33, 36, -38, -1, -20, 12, 2, 17, 49, 18, -53, 111, -46, -93, 35, -65, 91, -87, 20, 47, -9, 1, -57, -1, -51, 23, 119, 117, -92, -79, 106, 19, 29, -97, -107, -2, 55, -7, -1, 23, 120, -38, -10, 68, 62, -119, -66, 45, 9, 37, 123, 124, 113, -100, -47, 46, -113, 20, -30, -47, 50, 55, 94 };
    
    /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     * SECRET KEY components start here [replace via { 0 }] 
     * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     */
    byte[] x1 = { 0 }; 
    byte[] x2 = { 0 }; 
    byte[] y1 = { 0 }; 
    byte[] y2 = { 0 }; 
    byte[] z = { 0 }; 
    //****************************************
    
    pk = new PublicKey(2064,p,g1,g2,c,d,h,hg1,hg2);
    sk = new SecretKey(2064,p,x1,x2,y1,y2,z,hg1,hg2);
    
    
    
    /****************************************
     * Initiatize random generator
     ****************************************/
    
    rnd = new Random();
  }
  
  
  /************************************************************
   * Converter Methods
   ************************************************************/
  
  private BigInteger bits2BigInteger(boolean[] bits){
    int len = bits.length;
    byte[] bytes = new byte[2 + (len/8)];
    int b;
    int index = 1+ len/8;
    int bitIndex = 0;
    
    // in bits:  least significant bit comes first
    // in bytes: most significant bit is first!
    
    bytes[0] = 0;  // play safe - we do not want a negative number...
    bytes[1] = 0;
    
    while(bitIndex<len){
      b = 0;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|1;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|2;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|4;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|8;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|16;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|32;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|64;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|128;
      bytes[index--] = (byte)b;
    }
    return new BigInteger(bytes);
  }
  
  private boolean[] bigInteger2bits(int k, BigInteger b){
    boolean[] bits = new boolean[k];
    int i;
    
    for(i = 0; i< k; i++)
      bits[i] = b.testBit(i);
    return bits;
  }
  
  
  /************************************************************
   * Hashing
   ************************************************************/
  
  private BigInteger hashOnOneNumber(BigInteger p,
                               BigInteger hg1,
                               BigInteger hg2,
                               BigInteger nn){
    BigInteger q = p.shiftRight(1); // -1 div 2
    return hashOnTwoNumbers(p,hg1,hg2,nn.divide(q),nn.mod(q));
  }
  private BigInteger hashOnTwoNumbers(BigInteger p,
                                BigInteger hg1,
                                BigInteger hg2,
                                BigInteger a1,
                                BigInteger a2){
    return ((hg1.modPow(a1,p)).multiply(hg2.modPow(a2,p))).mod(p);
  }
  
  private BigInteger hashBitList(int k,
                           BigInteger p,
                           HashFunction hash,
                           boolean[] bits){
    BigInteger hg1 = hash.hash_g1;
    BigInteger hg2 = hash.hash_g2;
    
    int m   = k+k-2;
    int len = m - k - 1; // the length of ONE hash component
    int lengthDeficit = len - (bits.length % len);
    int index = - lengthDeficit; 
    int i;
    BigInteger arg;
    byte[] zero = {0};
    BigInteger res = new BigInteger(zero);
    BigInteger e;
    boolean[] transferList = new boolean[len];
    
    while(index < bits.length){
      // copy bits
      for(i = 0; i < len; i++){
  if(index < 0)
    transferList[i] = false;
  else
    transferList[i] = bits[index];
  index++;}
      
      arg = bits2BigInteger(transferList).add((res.shiftLeft(1)).setBit(0).shiftLeft(len));
      res = hashOnOneNumber(p, hg1, hg2, arg);
    }
    return res;
  }
  
  /************************************************************
   * Auxillary
   ************************************************************/
  
  private BigInteger bigRandom(int bits){
    // there should be a constructor with signature
    // BigInteger(int bits, Random rnd) that does that job....
    // only my compiler cannot find it for some reason.
    int nbytes = 2+bits/8;
    int i;
    int b;
    byte[] bytes = new byte[nbytes];
    
    for(i=1; i< nbytes; i++){
      b = (rnd.nextInt()) % 256;
      if(b>127)b = b - 256;
      bytes[i] = (byte)b;}
    bytes[0] = 1;
    
    return new BigInteger(bytes);
  };
  
  private boolean[] bitListOne(int k,
                         BigInteger b1){
    // LEAST significant bits first...
    boolean[] res = new boolean[k];
    int i;
    int index = 0;
    
    for(i = 0; i <k ; i++)
      res[index++] = b1.testBit(i);
    return res;
  }
  
  private boolean[] bitListThree(int k,
                           BigInteger b1,
                           BigInteger b2,
                           BigInteger b3){
    // LEAST significant bits first...
    boolean[] res = new boolean[3*k];
    int i;
    int index = 0;
    
    for(i = 0 ; i < k; i++)
      res[index++] = b1.testBit(i);
    for(i = 0 ; i < k; i++)
      res[index++] = b2.testBit(i);
    for(i = 0 ; i < k; i++)
      res[index++] = b3.testBit(i);
    
    return res;
  }
  private boolean[] bitListFour(int k,
                            BigInteger b1,
                            BigInteger b2,
                            BigInteger b3,
                            BigInteger b4){
  // least significant bits first...
  boolean[] res = new boolean[4*k];
  int i;
  int index = 0;

  for(i = 0 ; i < k; i++)
      res[index++] = b1.testBit(i);
  for(i = 0 ; i < k; i++)
      res[index++] = b2.testBit(i);
  for(i = 0 ; i < k; i++)
      res[index++] = b3.testBit(i);
  for(i = 0 ; i < k; i++)
      res[index++] = b4.testBit(i);

  return res;
    }

    /************************************************************
     * --  Encrypting  --
     ************************************************************/
    
  public boolean[] encrypt(boolean[] message){
  /***
   * Returns a (big) array representing the
   * concatenation of encryption blocks
   *        [u1 u2 e v]
   * Since the (bit-)length of each component of the block is given
   * with k, it is not necessary to encapsulate those additionally.
   **************************************************/
      
      int messageLength = message.length;
      int el            = pk.k - 1; // one 'bit' is not complete 
      int i;
      int toEncrypt     = (1+ (message.length / el))*pk.k*4;
      boolean[] mChunk  = new boolean[pk.k];
      mChunk[pk.k-1] = false;      // ignore most significant bit
      boolean[] cChunk  = new boolean[pk.k*4];
      boolean[] res     = new boolean[toEncrypt];
      int resIndex      = 0;
      
      BigInteger r,u1,u2,e,m,alpha,v;

      int pointer = 0;
      int index = 0;


      while(pointer < messageLength){
          index = 0;
          while((index < el)&&(pointer < messageLength))
              mChunk[index++] = message[pointer++];
		while(index + 1 < el){ // fill with random 01/10 bits
		    mChunk[index] = ( (rnd.nextInt() & 1) == 1);
		    mChunk[index+1] = !mChunk[index];
		    index = index + 2;
		}
          if(index < el)
            mChunk[index] = true;
          m  = bits2BigInteger(mChunk);
          if(m.equals(BigInteger.ZERO)){ // avoid to encrypt a '0'.
              mChunk[el] = true;         // instead fill throwaway-bit
              m = bits2BigInteger(mChunk);
          }

          r = bigRandom(pk.k+1).mod(pk.p);
          u1 = pk.g1.modPow(r,pk.p);
          u2 = pk.g2.modPow(r,pk.p);
          e  = ((pk.h.modPow(r,pk.p)).multiply(m)).mod(pk.p);
          alpha = hashBitList(pk.k,pk.p,pk.hash,bitListThree(pk.k,u1,u2,e));
          v = ((pk.c.modPow(r,pk.p)).multiply(pk.d.modPow(r.multiply(alpha),pk.p))).mod(pk.p);
          cChunk = bitListFour(pk.k,u1,u2,e,v);
          
          for(i=0; i < 4*pk.k; i++)
              res[resIndex++] = cChunk[i];
      }
      return res;

  }
    
    /************************************************************
     * --  Decrypting  --
     ************************************************************/

    public boolean[] decrypt(boolean[] cryptoText){
  boolean[] res = new boolean[((cryptoText.length / (4 * sk.k))+1)*(sk.k-1)];
  // one bit (the most significant one ) is always lost, since it is 0.
  
  boolean[] cChunk = new boolean[sk.k];
  boolean[] mChunk = new boolean[sk.k];
  BigInteger c;
  int index = 0;
  int resIndex = 0;
  int len   = cryptoText.length;
  int i;

  byte[] zero = {0};
  BigInteger zeroBig = new BigInteger(zero); // will be returned, if key is faulty
  BigInteger u1,u2,e,v,alpha,m;

  while(index+(4*sk.k) <= len){ // only decrypt complete blocks
      // Copy --- with all bits.
      for(i = 0; i< sk.k; i++)
          cChunk[i] = cryptoText[index++];
      u1 = bits2BigInteger(cChunk);
      for(i = 0; i< sk.k; i++)
          cChunk[i] = cryptoText[index++];
      u2 = bits2BigInteger(cChunk);
      for(i = 0; i< sk.k; i++)
          cChunk[i] = cryptoText[index++];
      e  = bits2BigInteger(cChunk);
      for(i = 0; i< sk.k; i++)
          cChunk[i] = cryptoText[index++];
      v = bits2BigInteger(cChunk);
      
      alpha = hashBitList(sk.k,sk.p,sk.hash,bitListThree(sk.k,u1,u2,e));
      
      if((v.equals(((u1.modPow(sk.x1.add(alpha.multiply(sk.y1)),sk.p)                    ).multiply(u2.modPow(sk.x2.add(alpha.multiply(sk.y2)),sk.p))).mod(sk.p))))
          {
		    if(u1.equals(BigInteger.ZERO))
                  m = BigInteger.ZERO;
              else
                  m = (e.multiply((u1.modPow(sk.z,sk.p)).modInverse(sk.p))).mod(sk.p);
              cChunk = bigInteger2bits(sk.k, m);
              for(i = 0; i < sk.k - 1; i++) // ignore most significant bit
                  res[resIndex++] = cChunk[i];
          }
      else
          for(i = 0; i < sk.k-1;  i++)
              res[resIndex++] = true; // fill with ones
  }
          
  return res;
    }
}


/**
 * Auxillary data structure for hash function
 * 
 */
class HashFunction {
    BigInteger hash_g1;
    BigInteger hash_g2;

    HashFunction(byte[] hash_g1_rep,
          byte[] hash_g2_rep){
  hash_g1 = new BigInteger(hash_g1_rep);
  hash_g2 = new BigInteger(hash_g2_rep);
    }
}

/**
 * Definition of the records structure of the keys<BR>
 *
 * The variable names used correspond to the ones in [CS98]
 *
 */







class SecretKey {
    int          k;        // number of bits
    BigInteger   p;        // prime modulus
    BigInteger   x1;          
    BigInteger   x2;
    BigInteger   y1;
    BigInteger   y2;
    BigInteger   z;
    HashFunction hash;
    
    SecretKey(int k_id,
        byte[] p_rep,
        byte[] x1_rep,
        byte[] x2_rep,
        byte[] y1_rep,
        byte[] y2_rep,
        byte[] z_rep,
        byte[] hash_g1_rep,
        byte[] hash_g2_rep){
  k = k_id;
  p  = new BigInteger(p_rep);
  x1 = new BigInteger(x1_rep);
  x2 = new BigInteger(x2_rep);
  y1 = new BigInteger(y1_rep);
  y2 = new BigInteger(y2_rep);
  z  = new BigInteger(z_rep);
  hash = new HashFunction(hash_g1_rep,hash_g2_rep);
    }
}

class PublicKey {
    int          k;
    BigInteger   p;
    BigInteger   g1;
    BigInteger   g2;
    BigInteger   c;
    BigInteger   d;
    BigInteger   h;
    HashFunction hash;

    PublicKey(int k_id,
        byte[] p_rep,
        byte[] g1_rep,
        byte[] g2_rep,
        byte[] c_rep,
        byte[] d_rep,
        byte[] h_rep,
        byte[] hash_g1_rep,
        byte[] hash_g2_rep){
  k  = k_id;
  p  = new BigInteger(p_rep);
  g1 = new BigInteger(g1_rep);
  g2 = new BigInteger(g2_rep);
  c  = new BigInteger(c_rep);
  d  = new BigInteger(d_rep);
  h  = new BigInteger(h_rep);
  hash = new HashFunction(hash_g1_rep,hash_g2_rep);
    }
}






